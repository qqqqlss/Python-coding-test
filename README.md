# Python-coding-test
use dictionary for hash in python  
hash_1 - 딕셔너리 이용해 hash구분  key,value,items  
hash_2 - for 문에서 딕셔너리가 리스트 보다 빠름 ! startswitch 특정문자로 사용하는 여부.  
stack_queue_1 - 빈 리스트 선언해서 사용 시 값 직접 넣기 위해 insert,append사용 [n]으로 대입은 불가, ++사용불가
stack_queue_2 -
stack_queue_3 -
stack_queue_4 -
heap_1 - 최소,최대 값 구할 때는 heap이 빠름(완전이진트리의 일종으로 값을 추가하면 마지막에 넣고 값을 교환하며 완성(자동정렬)  
heap_2 - 힙과 이차원 배열을 이용해 값 같이 이용 
heap_3 - 최대힙 사용법(-x,x) 사용
sort_1 - //  
brute_force_1 - enumertate 활용하면, +1되는 변수 더 쉽게 활용가능
brute_force_2 - 리스트 복사시 리스트의 주소가 복사되기 때문에 [:]활용해서 복사해야 값이 들어감.  
brute_force_3 -  
greedy_1 - //
greedy_2 - //
greedy_3 - 문자열 리스트는 인덱스 요소제거 안되서 s[x:x]+s[x:x]요런식으로 표현
greedy_4 - 리스트 자체를 건드리는 것(pop,slicing,del)보다 인덱스를 활용해서 푸는게 훨씬 빠르다.
dynamic_programming_1 - 최대한 효율적으로 줄여보기.. 리스트 변수에 변수 넣으면 주소값이 넣어짐. copy:O(N)
dfs_bfs_1 - 전역 변수 사용시 global 선언 필요, dfs는 하나하나 끝까지 차례대로 bfs는 여러개를 높이별로 계산? 
binary_search_1 - 범위에서 반씩 줄여가며 경우의 수를 줄임. 
graph_1 - for 에 _ 사용 반복만 사용시. 리스트 여러개 활용하는법. for (a,b)이런 식으로 다차원 배열 변수로 사용 pop이용해서 빼면서 값 넣음.
hash_3 - //
hash_4 - filter랑 lamda 활용방법, class활용 방법